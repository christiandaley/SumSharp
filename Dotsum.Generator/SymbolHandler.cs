using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Dotsum.Generator;

internal class SymbolHandler
{
    public record CaseData(int Index, string Name, string? Type);

    public StringBuilder Builder { get; }

    public string? Namespace { get; }

    public bool IsStruct { get; }

    public string Accessibility { get; }

    public bool IsGenericType => TypeArguments.Length > 0;

    public string[] TypeArguments { get; }

    public string NameWithoutTypeArguments { get; }

    public string Name { get; }

    public CaseData[] Cases { get; }

    public CaseData[] UniqueCases { get; }

    public string ValueType { get; }

    public INamedTypeSymbol[] ContainingTypes;

    public bool EnableStandardJsonSerialization { get; }

    public bool UsingSourceGeneration { get; }

    public SymbolHandler(
        StringBuilder builder,
        INamedTypeSymbol symbol,
        INamedTypeSymbol caseAttrSymbol,
        INamedTypeSymbol enableJsonSerializationAttrSymbol)
    {
        Builder = builder;
        
        Namespace =
            symbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : symbol.ContainingNamespace.ToDisplayString();

        IsStruct = GetIsStruct(symbol);

        Accessibility = GetAccessibility(symbol);

        TypeArguments = [.. symbol.TypeArguments.Select(arg => arg.ToString())];

        NameWithoutTypeArguments = symbol.Name;

        Name = GetFullName(symbol);

        Cases = symbol!
            .GetAttributes()
            .Where(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, caseAttrSymbol))
            .Select((attr, i) =>
            {
                return attr.ConstructorArguments switch
                {
                    [var caseName] => new CaseData(i, caseName.Value!.ToString(), null),
                    [var caseName, var caseType] => new CaseData(i, caseName.Value!.ToString(), caseType.Value!.ToString())
                };
            })
            .ToArray();

        UniqueCases =
            Cases
            .Where(caseData => caseData.Type is not null)
            .GroupBy(caseData => caseData.Type)
            .Where(group => group.Count() == 1)
            .SelectMany(group => group)
            .ToArray();

        var distinctTypes =
            Cases
            .Select(caseData => caseData.Type)
            .Where(type => type != null)
            .Distinct()
            .ToArray();

        ValueType = distinctTypes.Length == 0 ? distinctTypes[0]! : "object";

        var enableJsonSerializationData =
            symbol!
            .GetAttributes()
            .Where(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, enableJsonSerializationAttrSymbol))
            .SingleOrDefault();

        EnableStandardJsonSerialization = enableJsonSerializationData != null;

        if (enableJsonSerializationData != null)
        {
            EnableStandardJsonSerialization = true;

            UsingSourceGeneration = enableJsonSerializationData.ConstructorArguments[0].Value as bool? ?? false;
        }

        UsingSourceGeneration =
            EnableStandardJsonSerialization ?
            (bool)enableJsonSerializationData!.ConstructorArguments[0].Value! :
            false;

        var containingTypes = new List<INamedTypeSymbol>();

        symbol = symbol.ContainingType;

        while (symbol != null)
        {
            containingTypes.Add(symbol);

            symbol = symbol.ContainingType;
        }

        ContainingTypes = [.. containingTypes];
    }

    private bool GetIsStruct(INamedTypeSymbol symbol) => symbol.TypeKind == TypeKind.Struct;

    private string GetAccessibility(INamedTypeSymbol symbol)
    {
        return symbol.DeclaredAccessibility switch
        {
            Microsoft.CodeAnalysis.Accessibility.Public => "public",
            Microsoft.CodeAnalysis.Accessibility.Internal => "internal",
            Microsoft.CodeAnalysis.Accessibility.Protected => "protected",
            Microsoft.CodeAnalysis.Accessibility.ProtectedOrInternal => "protected internal",
            Microsoft.CodeAnalysis.Accessibility.Private => "private"
        };
    }

    private string GetFullName(INamedTypeSymbol symbol)
    {
        return
            symbol.TypeArguments.Length > 0 ?
            $"{symbol.Name}<{string.Join(", ", symbol.TypeArguments)}>" :
            symbol.Name;
    }

    public string Emit()
    {
        Builder.AppendLine("// <auto-generated />");

        Builder.AppendLine("#pragma warning disable CS8509");

        Builder.AppendLine("using System.Threading.Tasks;");

        if (Namespace != null)
        {
            EmitBeginNamespace();
        }

        EmitContainingTypes();

        if (EnableStandardJsonSerialization && !UsingSourceGeneration)
        {
            EmitJsonConverterAttribute();
        }

        EmitClassDeclaration();

        EmitCaseConstructors();

        EmitSwitch();

        EmitSwitchAsync();

        EmitMatch();

        EmitIs();

        EmitAs();

        EmitIf();

        EmitIfAsync();

        EmitImplicitConversions();

        if (EnableStandardJsonSerialization && !IsGenericType)
        {
            EmitStandardJsonConverter();
        }

        EmitEndClassDeclaration();

        if (IsGenericType && EnableStandardJsonSerialization)
        {
            EmitStaticClass();

            EmitStandardJsonConverterFactory();

            EmitEndStaticClass();
        }

        EmitEndContainingTypes();

        EmitEndNamespace();

        return Builder.ToString();
    }

    private void EmitBeginNamespace()
    {
        Builder.AppendLine($@"namespace {Namespace}
{{");
    }

    private void EmitContainingTypes()
    {
        foreach (var symbol in ContainingTypes)
        {
            Builder.AppendLine($@"
{GetAccessibility(symbol)} partial {(GetIsStruct(symbol) ? "struct" : "class")} {GetFullName(symbol)}
{{");

        }
    }

    private void EmitJsonConverterAttribute()
    {
        Builder.Append($@"
[System.Text.Json.Serialization.JsonConverter(typeof({NameWithoutTypeArguments}.StandardJsonConverter))]");
    }

    private void EmitClassDeclaration()
    {
        Builder.AppendLine($@"
{Accessibility} partial {(IsStruct ? "struct" : "class")} {Name} : IEquatable<{Name}>
{{
    public int Index {{ get; }}

    internal readonly {ValueType} _value;

    private {NameWithoutTypeArguments}(int index, {ValueType} value)
    {{
        System.Diagnostics.Debug.Assert(index >= 0 && index < {Cases.Length});

        Index = index;
        _value = value;
    }}

    public bool Equals({Name} other) => {(IsStruct ? "" : "other is not null && ")}other.Index == Index && Equals(_value, other._value);

    public override bool Equals(object obj)
    {{
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != GetType()) return false;

        return Equals(({Name})obj);
    }}

    public override int GetHashCode() => HashCode.Combine(Index, _value);

    public static bool operator==({Name} left, {Name} right) => left.Equals(right);

    public static bool operator!=({Name} left, {Name} right) => !left.Equals(right);");
    }
    private void EmitCaseConstructors()
    {
        foreach (var caseData in Cases)
        {
            if (caseData.Type == null)
            {
                Builder.AppendLine($@"
    public static readonly {Name} {caseData.Name} = new({caseData.Index}, default);");
            }
            else
            {
                Builder.AppendLine($@"
    public static {Name} {caseData.Name}({caseData.Type} value) => new({caseData.Index}, value);");
            }
        }
    }
    private void EmitSwitch()
    {
        Builder.Append($@"
    public void Switch(");

        Builder.Append(string.Join(", ", Cases.Select(caseData =>
        {
            if (caseData.Type == null)
            {
                return $"Action f{caseData.Index}";
            }
            else
            {
                return $"Action<{caseData.Type}> f{caseData.Index}";
            }
        })));

        Builder.Append(")");

        Builder.AppendLine(@"
    {
        switch (Index)
        {");

        foreach (var caseData in Cases)
        {
            var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

            Builder.AppendLine($@"
        case {caseData.Index}: f{caseData.Index}({arg}); break;");
        }

        Builder.AppendLine(@"
        }
    }");
    }

    private void EmitSwitchAsync()
    {
        Builder.Append($@"
    public Task Switch(");

        Builder.Append(string.Join(", ", Cases.Select(caseData =>
        {
            if (caseData.Type == null)
            {
                return $"Func<Task> f{caseData.Index}";
            }
            else
            {
                return $"Func<{caseData.Type}, Task> f{caseData.Index}";
            }
        })));

        Builder.Append(")");

        Builder.AppendLine(@"
    {
        return Index switch
        {");

        foreach (var caseData in Cases)
        {
            var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

            Builder.AppendLine($@"
            {caseData.Index} => f{caseData.Index}({arg}),");
        }

        Builder.AppendLine(@"
        };
    }");
    }

    private void EmitMatch()
    {
        Builder.Append($@"
    public TRet_ Match<TRet_>(");

        Builder.Append(string.Join(", ", Cases.Select(caseData =>
        {
            if (caseData.Type == null)
            {
                return $"Func<TRet_> f{caseData.Index}";
            }
            else
            {
                return $"Func<{caseData.Type}, TRet_> f{caseData.Index}";
            }
        })));

        Builder.Append(")");

        Builder.AppendLine(@"
    {
        return Index switch
        {");

        foreach (var caseData in Cases)
        {
            var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

            Builder.AppendLine($@"
            {caseData.Index} => f{caseData.Index}({arg}),");
        }

        Builder.AppendLine(@"
        };
    }");
    }

    public void EmitIs()
    {
        foreach (var caseData in Cases)
        {
            Builder.AppendLine($@"
    public bool Is{caseData.Name} => Index == {caseData.Index};");
        }
    }

    public void EmitAs()
    {
        foreach (var caseData in Cases)
        {
            if (caseData.Type == null)
            {
                continue;
            }

            Builder.AppendLine($@"
    public {caseData.Type} As{caseData.Name} => Index == {caseData.Index} ? ({caseData.Type})_value : throw new InvalidOperationException($""Attempted to access case index {caseData.Index} but index is {{Index}}"");");
        }
    }

    private void EmitIf()
    {
        foreach (var caseData in Cases)
        {
            var argType = caseData.Type == null ? "Action" : $"Action<{caseData.Type}>";

            var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

            Builder.Append($@"
    public void If{caseData.Name}({argType} f)");
            Builder.AppendLine($@"
    {{
        if (Index == {caseData.Index})
        {{
            f({arg});
        }}
    }}");
        }
    }

    private void EmitIfAsync()
    {
        foreach (var caseData in Cases)
        {
            var argType = caseData.Type == null ? "Func<Task>" : $"Func<{caseData.Type}, Task>";

            var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

            Builder.AppendLine($@"
    public ValueTask If{caseData.Name}({argType} f) => Index == {caseData.Index} ? new ValueTask(f({arg})) : ValueTask.CompletedTask;");
        }
    }

    private void EmitImplicitConversions()
    {
        foreach (var caseData in UniqueCases)
        {
            Builder.AppendLine($@"
    public static implicit operator {Name}({caseData.Type} value) => {caseData.Name}(value);");
        }
    }

    private void EmitStandardJsonConverter()
    {
        Builder.Append($@"
    {(IsGenericType ? "private" : "public")} partial class {(IsGenericType ? $"JsonConverter<{string.Join(", ", TypeArguments)}>" : "StandardJsonConverter")} : System.Text.Json.Serialization.JsonConverter<{Name}>
    {{
        public override {Name} Read(ref System.Text.Json.Utf8JsonReader reader, Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
        {{
            if (reader.TokenType == System.Text.Json.JsonTokenType.Null)
            {{
                return default;
            }}

            if (reader.TokenType != System.Text.Json.JsonTokenType.StartObject)
            {{
                throw new System.Text.Json.JsonException($""Expected StartObject token but found: {{reader.TokenType}}"");
            }}

            reader.Read();

            if (reader.TokenType != System.Text.Json.JsonTokenType.PropertyName)
            {{
                throw new System.Text.Json.JsonException($""Expected PropertyName token but found: {{reader.TokenType}}"");
            }}

            var index = int.Parse(reader.GetString());

            reader.Read();

            var ret = index switch
            {{");

        foreach (var caseData in Cases)
        {
            if (caseData.Type == null)
            {
                Builder.Append($@"
                {caseData.Index} => {Name}.{caseData.Name},");
            }
            else
            {
                Builder.Append($@"
                {caseData.Index} => {Name}.{caseData.Name}(System.Text.Json.JsonSerializer.Deserialize<{caseData.Type}>(ref reader, options)),");
            }
        }

        Builder.Append($@"
            }};

            reader.Read();

            if (reader.TokenType != System.Text.Json.JsonTokenType.EndObject)
            {{
                throw new System.Text.Json.JsonException($""Expected EndObject token but found: {{reader.TokenType}}"");
            }}

            return ret;
        }}

        public override void Write(System.Text.Json.Utf8JsonWriter writer, {Name} value, System.Text.Json.JsonSerializerOptions options)
        {{
            writer.WriteStartObject();

            switch (value.Index)
            {{");

        foreach (var caseData in Cases)
        {
            Builder.Append($@"
            case {caseData.Index}:");

            if (caseData.Type == null)
            {
                Builder.AppendLine($@"
                writer.WriteNull(""{caseData.Index}"");");
            }
            else
            {
                Builder.Append($@"
                writer.WritePropertyName(""{caseData.Index}"");");

                Builder.AppendLine($@"
                System.Text.Json.JsonSerializer.Serialize(writer, value._value, options);");
            }

            Builder.Append($@"
                break;");
        }

        Builder.AppendLine(@"
            }

            writer.WriteEndObject();
        }
    }");
    }
    private void EmitEndClassDeclaration()
    {
        Builder.AppendLine("}");
    }

    private void EmitStaticClass()
    {
        Builder.AppendLine($@"

{Accessibility} static partial class {NameWithoutTypeArguments}
{{
");
    }

    private void EmitStandardJsonConverterFactory()
    {
        Builder.AppendLine($@"
    public partial class StandardJsonConverter : System.Text.Json.Serialization.JsonConverterFactory
    {{
        public override bool CanConvert(Type typeToConvert)
        {{
            return typeToConvert.IsGenericType &&
                   typeToConvert.GetGenericTypeDefinition() == typeof({NameWithoutTypeArguments}<{new string(',', TypeArguments.Length - 1)}>);
        }}

        public override System.Text.Json.Serialization.JsonConverter CreateConverter(Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
        {{
            return (System.Text.Json.Serialization.JsonConverter)System.Activator.CreateInstance(typeof(JsonConverter<{new string(',', TypeArguments.Length - 1)}>).MakeGenericType(typeToConvert.GetGenericArguments()));
        }}");

        EmitStandardJsonConverter();

        Builder.Append(@"
    }");
    }

    private void EmitEndStaticClass()
    {
        Builder.AppendLine(@"
}");
    }

    private void EmitEndContainingTypes()
    {
        foreach (var symbol in ContainingTypes)
        {
            Builder.AppendLine("}");
        }
    }

    private void EmitEndNamespace()
    {
        if (!string.IsNullOrWhiteSpace(Namespace))
        {
            Builder.AppendLine("}");
        }
    }
}
