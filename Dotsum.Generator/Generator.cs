using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml.Linq;

namespace Dotsum;

[Generator]
public class Generator : IIncrementalGenerator
{
    record CaseData(int Index, string Name, string? Type);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var dotsumClasses = 
            context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "Dotsum.CaseAttribute",
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => ctx.TargetSymbol as INamedTypeSymbol)
            .Where(static m => m is not null)
            .Collect();

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(dotsumClasses),
            static (spc, source) => Execute(source.Left, source.Right!, spc));

        static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node switch
            {
                ClassDeclarationSyntax c => c.Modifiers.Any(SyntaxKind.PartialKeyword),
                StructDeclarationSyntax s => s.Modifiers.Any(SyntaxKind.PartialKeyword),
                _ => false,
            };
        }

        /*static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context)
        {
            var symbol = context.TargetSymbol;

            if (symbol is not INamedTypeSymbol namedTypeSymbol)
            {
                return null;
            }

            var attributeData = namedTypeSymbol.GetAttributes().FirstOrDefault(ad =>
                string.Equals(ad.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), "global::Dotsum.CaseAttribute"));

            return attributeData is null ? null : namedTypeSymbol;
        }*/
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol> targets, SourceProductionContext context)
    {
        var caseAttrSymbol = compilation.GetTypeByMetadataName("Dotsum.CaseAttribute")!;

        var sb = new StringBuilder();

        foreach (var symbol in targets.Distinct(SymbolEqualityComparer.Default))
        {
            sb.Clear();

            HandleSymbol((INamedTypeSymbol)symbol!);
        }

        void HandleSymbol(INamedTypeSymbol symbol)
        {
            var ns =
                symbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : symbol.ContainingNamespace.ToDisplayString();

            sb.AppendLine("// <auto-generated />");

            sb.AppendLine("#pragma warning disable CS8509");

            if (!string.IsNullOrWhiteSpace(ns))
            {
                sb.AppendLine($"namespace {ns} {{");
            }

            var isStruct = symbol.TypeKind == TypeKind.Struct;

            var accessibility = symbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                Accessibility.Protected => "protected",
                Accessibility.ProtectedAndInternal => "protected internal",
                Accessibility.Private => "private",
            };

            bool isGenericType = symbol.TypeArguments.Length > 0;

            var typeArguments = isGenericType ? $"<{string.Join(", ", symbol.TypeArguments)}>" : "";

            var nameWithoutTypeArguments = symbol.Name;

            var name = $"{nameWithoutTypeArguments}{typeArguments}";

            var cases = symbol!
                .GetAttributes()
                .Where(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, caseAttrSymbol))
                .Select((attr, i) =>
                {
                    return attr.ConstructorArguments switch
                    {
                        [var caseName] => new CaseData(i, caseName.Value!.ToString(), null),
                        [var caseName, var caseType] => new CaseData(i, caseName.Value!.ToString(), caseType.Value!.ToString())
                    };
                })
                .ToArray();

            // COMMON MEMBERS

            sb.AppendLine($@"
{accessibility} partial {(isStruct ? "struct" : "class")} {name} : IEquatable<{name}>
{{
    private object _value;

    public int Index {{ get; private set; }}

    private {nameWithoutTypeArguments}(int index, object value)
    {{
        Index = index;
        _value = value;
    }}

    public bool Equals({name} other) => other is not null && other.Index == Index && Equals(_value, other._value);

    public override bool Equals(object obj)
    {{
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != GetType()) return false;

        return Equals(({name})obj);
    }}

    public override int GetHashCode() => HashCode.Combine(Index, _value);

    public static bool operator==({name} left, {name} right) => left.Equals(right);

    public static bool operator!=({name} left, {name} right) => !left.Equals(right);");

            // CASE CONSTRUCTORS

            foreach (var caseData in cases)
            {
                if (caseData.Type == null)
                {
                    sb.AppendLine($@"
    public static readonly {name} {caseData.Name} = new({caseData.Index}, null);");
                }
                else
                {
                    sb.AppendLine($@"
    public static {name} {caseData.Name}({caseData.Type} value) => new({caseData.Index}, value);");
                }
            }

            // SWITCH

            sb.Append($@"
    public void Switch(");

            sb.Append(string.Join(", ", cases.Select(caseData =>
            {
                if (caseData.Type == null)
                {
                    return $"Action f{caseData.Index}";
                }
                else
                {
                    return $"Action<{caseData.Type}> f{caseData.Index}";
                }
            })));

            sb.Append(")");

            sb.AppendLine(@"
    {
        switch (Index)
        {");

            foreach (var caseData in cases)
            {
                var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

                sb.AppendLine($@"
        case {caseData.Index}: f{caseData.Index}({arg}); break;");
            }

            sb.AppendLine(@"
        }
    }");

            // MATCH

            sb.Append($@"
    public TRet_ Match<TRet_>(");

            sb.Append(string.Join(", ", cases.Select(caseData =>
            {
                if (caseData.Type == null)
                {
                    return $"Func<TRet_> f{caseData.Index}";
                }
                else
                {
                    return $"Func<{caseData.Type}, TRet_> f{caseData.Index}";
                }
            })));

            sb.Append(")");

            sb.AppendLine(@"
    {
        return Index switch
        {");

            foreach (var caseData in cases)
            {
                var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

                sb.AppendLine($@"
            {caseData.Index} => f{caseData.Index}({arg}),");
            }

            sb.AppendLine(@"
        };
    }");
            // Is*

            foreach (var caseData in cases)
            {
                sb.AppendLine($@"
    public bool Is{caseData.Name} => Index == {caseData.Index};");
            }

            // If*

            foreach (var caseData in cases)
            {
                var argType = caseData.Type == null ? "Action" : $"Action<{caseData.Type}>";

                var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

                sb.AppendLine($@"
    public void If{caseData.Name}({argType} f)");
                sb.AppendLine($@"
    {{
        if (Index == {caseData.Index})
        {{
            f({arg});
        }}
    }}");
            }

            // END DEFINITION

            sb.AppendLine("}");

            if (!string.IsNullOrWhiteSpace(ns))
            {
                sb.AppendLine("}");
            }

            context.AddSource($"{symbol.Name}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }
}