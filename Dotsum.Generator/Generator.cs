using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Dotsum;

[Generator]
public class Generator : IIncrementalGenerator
{
    record CaseData(int Index, string Name, string? Type);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var dotsumClasses = 
            context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "Dotsum.CaseAttribute",
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => ctx.TargetSymbol as INamedTypeSymbol)
            .Where(static m => m is not null)
            .Collect();

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(dotsumClasses),
            static (spc, source) => Execute(source.Left, source.Right!, spc));

        static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node switch
            {
                ClassDeclarationSyntax c => c.Modifiers.Any(SyntaxKind.PartialKeyword),
                StructDeclarationSyntax s => s.Modifiers.Any(SyntaxKind.PartialKeyword),
                _ => false,
            };
        }

        /*static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context)
        {
            var symbol = context.TargetSymbol;

            if (symbol is not INamedTypeSymbol namedTypeSymbol)
            {
                return null;
            }

            var attributeData = namedTypeSymbol.GetAttributes().FirstOrDefault(ad =>
                string.Equals(ad.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), "global::Dotsum.CaseAttribute"));

            return attributeData is null ? null : namedTypeSymbol;
        }*/
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol> targets, SourceProductionContext context)
    {
        var caseAttrSymbol = compilation.GetTypeByMetadataName("Dotsum.CaseAttribute")!;

        var enableJsonSymbol = compilation.GetTypeByMetadataName("Dotsum.EnableJsonSerializationAttribute")!;

        var sb = new StringBuilder();

        foreach (var symbol in targets.Distinct(SymbolEqualityComparer.Default))
        {
            sb.Clear();

            HandleSymbol((INamedTypeSymbol)symbol!);
        }

        void HandleSymbol(INamedTypeSymbol symbol)
        {
            var ns =
                symbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : symbol.ContainingNamespace.ToDisplayString();

            sb.AppendLine("// <auto-generated />");

            sb.AppendLine("#pragma warning disable CS8509");

            sb.AppendLine("using System.Threading.Tasks;");

            if (!string.IsNullOrWhiteSpace(ns))
            {
                sb.AppendLine($"namespace {ns} {{");
            }

            var isStruct = symbol.TypeKind == TypeKind.Struct;

            var accessibility = symbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                Accessibility.Protected => "protected",
                Accessibility.ProtectedAndInternal => "protected internal",
                Accessibility.Private => "private",
            };

            bool isGenericType = symbol.TypeArguments.Length > 0;

            var typeArguments = isGenericType ? $"<{string.Join(", ", symbol.TypeArguments)}>" : "";

            var nameWithoutTypeArguments = symbol.Name;

            var name = $"{nameWithoutTypeArguments}{typeArguments}";

            var cases = symbol!
                .GetAttributes()
                .Where(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, caseAttrSymbol))
                .Select((attr, i) =>
                {
                    return attr.ConstructorArguments switch
                    {
                        [var caseName] => new CaseData(i, caseName.Value!.ToString(), null),
                        [var caseName, var caseType] => new CaseData(i, caseName.Value!.ToString(), caseType.Value!.ToString())
                    };
                })
                .ToArray();

            var uniqueCases =
                cases
                .Where(caseData => caseData.Type is not null)
                .GroupBy(caseData => caseData.Type)
                .Where(group => group.Count() == 1)
                .SelectMany(group => group)
                .ToArray();

            var distinctTypes =
                cases
                .Select(caseData => caseData.Type)
                .Where(type => type != null)
                .Distinct()
                .ToArray();

            var valueType = distinctTypes.Length == 1 ? distinctTypes[0]! : "object";

            var enableJsonSerialization =
                symbol!
                .GetAttributes()
                .Where(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, enableJsonSymbol))
                .SingleOrDefault();

            if (enableJsonSerialization != null)
            {
                sb.Append($@"
[System.Text.Json.Serialization.JsonConverter(typeof({nameWithoutTypeArguments}.StandardJsonConverter))]");
            }

            // COMMON MEMBERS

            sb.AppendLine($@"
{accessibility} partial {(isStruct ? "struct" : "class")} {name} : IEquatable<{name}>
{{
    public int Index {{ get; }}

    internal readonly {valueType} _value;

    private {nameWithoutTypeArguments}(int index, {valueType} value)
    {{
        System.Diagnostics.Debug.Assert(index >= 0 && index < {cases.Length});

        Index = index;
        _value = value;
    }}

    public bool Equals({name} other) => {(isStruct ? "" : "other is not null && ")}other.Index == Index && Equals(_value, other._value);

    public override bool Equals(object obj)
    {{
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != GetType()) return false;

        return Equals(({name})obj);
    }}

    public override int GetHashCode() => HashCode.Combine(Index, _value);

    public static bool operator==({name} left, {name} right) => left.Equals(right);

    public static bool operator!=({name} left, {name} right) => !left.Equals(right);");

            // CASE CONSTRUCTORS

            foreach (var caseData in cases)
            {
                if (caseData.Type == null)
                {
                    sb.AppendLine($@"
    public static readonly {name} {caseData.Name} = new({caseData.Index}, default);");
                }
                else
                {
                    sb.AppendLine($@"
    public static {name} {caseData.Name}({caseData.Type} value) => new({caseData.Index}, value);");
                }
            }

            // SWITCH

            sb.Append($@"
    public void Switch(");

            sb.Append(string.Join(", ", cases.Select(caseData =>
            {
                if (caseData.Type == null)
                {
                    return $"Action f{caseData.Index}";
                }
                else
                {
                    return $"Action<{caseData.Type}> f{caseData.Index}";
                }
            })));

            sb.Append(")");

            sb.AppendLine(@"
    {
        switch (Index)
        {");

            foreach (var caseData in cases)
            {
                var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

                sb.AppendLine($@"
        case {caseData.Index}: f{caseData.Index}({arg}); break;");
            }

            sb.AppendLine(@"
        }
    }");

            // SWITCH ASYNC

            sb.Append($@"
    public Task Switch(");

            sb.Append(string.Join(", ", cases.Select(caseData =>
            {
                if (caseData.Type == null)
                {
                    return $"Func<Task> f{caseData.Index}";
                }
                else
                {
                    return $"Func<{caseData.Type}, Task> f{caseData.Index}";
                }
            })));

            sb.Append(")");

            sb.AppendLine(@"
    {
        return Index switch
        {");

            foreach (var caseData in cases)
            {
                var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

                sb.AppendLine($@"
            {caseData.Index} => f{caseData.Index}({arg}),");
            }

            sb.AppendLine(@"
        };
    }");

            // MATCH

            sb.Append($@"
    public TRet_ Match<TRet_>(");

            sb.Append(string.Join(", ", cases.Select(caseData =>
            {
                if (caseData.Type == null)
                {
                    return $"Func<TRet_> f{caseData.Index}";
                }
                else
                {
                    return $"Func<{caseData.Type}, TRet_> f{caseData.Index}";
                }
            })));

            sb.Append(")");

            sb.AppendLine(@"
    {
        return Index switch
        {");

            foreach (var caseData in cases)
            {
                var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

                sb.AppendLine($@"
            {caseData.Index} => f{caseData.Index}({arg}),");
            }

            sb.AppendLine(@"
        };
    }");
            // Is*

            foreach (var caseData in cases)
            {
                sb.AppendLine($@"
    public bool Is{caseData.Name} => Index == {caseData.Index};");
            }

            // If*

            foreach (var caseData in cases)
            {
                var argType = caseData.Type == null ? "Action" : $"Action<{caseData.Type}>";

                var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

                sb.Append($@"
    public void If{caseData.Name}({argType} f)");
                sb.AppendLine($@"
    {{
        if (Index == {caseData.Index})
        {{
            f({arg});
        }}
    }}");
            }

            // If* ASYNC

            foreach (var caseData in cases)
            {
                var argType = caseData.Type == null ? "Func<Task>" : $"Func<{caseData.Type}, Task>";

                var arg = caseData.Type == null ? "" : $"({caseData.Type})_value";

                sb.AppendLine($@"
    public ValueTask If{caseData.Name}({argType} f) => Index == { caseData.Index} ? new ValueTask(f({arg})) : ValueTask.CompletedTask;");
            }

            // IMPLICIT CONVERSIONS

            foreach (var caseData in uniqueCases)
            {
                sb.AppendLine($@"
    public static implicit operator {name}({caseData.Type} value) => {caseData.Name}(value);");
            }
            
            // Non generic standard JSON serialization

            if (enableJsonSerialization != null && !isGenericType)
            {
                sb.Append($@"
    public partial class StandardJsonConverter : System.Text.Json.Serialization.JsonConverter<{name}>
    {{
        public override {name}? Read(ref System.Text.Json.Utf8JsonReader reader, Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
        {{
            if (reader.TokenType == System.Text.Json.JsonTokenType.Null)
            {{
                return default;
            }}

            if (reader.TokenType != System.Text.Json.JsonTokenType.StartObject)
            {{
                throw new System.Text.Json.JsonException($""Expected StartObject token but found: {{reader.TokenType}}"");
            }}

            reader.Read();

            if (reader.TokenType != System.Text.Json.JsonTokenType.PropertyName)
            {{
                throw new System.Text.Json.JsonException($""Expected PropertyName token but found: {{reader.TokenType}}"");
            }}

            var index = int.Parse(reader.GetString());

            reader.Read();

            var ret = index switch
            {{");

                foreach (var caseData in cases)
                {
                    if (caseData.Type == null)
                    {
                        sb.Append($@"
                {caseData.Index} => {name}.{caseData.Name},");
                    }
                    else
                    {
                        sb.Append($@"
                {caseData.Index} => {name}.{caseData.Name}(System.Text.Json.JsonSerializer.Deserialize<{caseData.Type}>(ref reader, options)),");
                    }
                }

                sb.Append($@"
            }};

            reader.Read();

            if (reader.TokenType != System.Text.Json.JsonTokenType.EndObject)
            {{
                throw new System.Text.Json.JsonException($""Expected EndObject token but found: {{reader.TokenType}}"");
            }}

            return ret;
        }}

        public override void Write(System.Text.Json.Utf8JsonWriter writer, {name} value, System.Text.Json.JsonSerializerOptions options)
        {{
            writer.WriteStartObject();

            switch (value.Index)
            {{");

                foreach (var caseData in cases)
                {
                    sb.AppendLine($@"
            case {caseData.Index}:");

                    if (caseData.Type == null)
                    {
                        sb.AppendLine($@"
                writer.WriteNull(""{caseData.Index}"");");
                    }
                    else
                    {
                        sb.Append($@"
                writer.WritePropertyName(""{caseData.Index}"");");

                        sb.AppendLine($@"
                System.Text.Json.JsonSerializer.Serialize(writer, value._value, options);");
                    }

                    sb.Append($@"
                break;");
                }

                sb.AppendLine(@"
            }

            writer.WriteEndObject();
        }
    }");
            }

            // END DEFINITION

            sb.AppendLine("}");

            if (!string.IsNullOrWhiteSpace(ns))
            {
                sb.AppendLine("}");
            }

            context.AddSource($"{symbol.Name}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }
}